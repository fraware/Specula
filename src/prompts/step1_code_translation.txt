You are a TLA+ specification expert. Your task is to translate source code into a TLA+ specification that faithfully models the imperative control flow and state transitions. **Focus on statement-by-statement translation of core logic functions.**

## Translation Requirements:

1. **Selective Function Modeling**: Categorize functions into three types:
   - **Core Logic Functions**: Main business logic that must be translated statement-by-statement as TLA+ actions
   - **Helper/Utility Functions**: Supporting functions that should be abstracted or simplified
   - **Infrastructure Functions**: Logging, tracing, debugging functions that should be omitted

2. **System Balance Priority**: For distributed systems like Raft, ensure EQUAL implementation of:
   - **Leader Election**: Vote handling, term management, state transitions
   - **Log Replication**: Entry appending, consistency checks, commit advancement
   - Both subsystems must be fully represented as TLA+ actions

3. **Function-to-Action Mapping**: Each CORE function must correspond to exactly one TLA+ action with the same name.

4. **State Variables**: Extract only the ESSENTIAL state variables relevant to the core logic.

5. **Syntax Correctness**: The specification must pass TLA+ SANY validation (syntactic correctness).

## TLA+ Template Structure:

```tla
---- MODULE ModuleName ----
EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS [Define any constants needed]

VARIABLES 
    [List all state variables from the code]

vars == <<[comma-separated list of all variables]>>

TypeInvariant == 
    [Define type constraints for all variables]

Init == 
    [Initialize all variables to appropriate starting values]

\* Action for each core function in the source code
FunctionName(parameters) ==
    [Translate function body to TLA+ operations]

Next == 
    \/ \E [parameters] : FunctionName([parameters])
    [Include ALL actions corresponding to core functions]

Spec == Init /\ [][Next]_vars

TypeOK == TypeInvariant

====
```

## Translation Guidelines:

1. **Variable Declarations**: 
   - Extract all class fields, global variables, and important local variables
   - Use appropriate TLA+ types (BOOLEAN, Nat, sequences, sets, records)

2. **Rigorous Function Translation (CRITICAL)**:
   - Keep the same function name for the TLA+ action
   - Include function parameters as action parameters
   - **Translate EVERY statement in core functions line-by-line**
   - **Preserve the exact execution order of all operations**
   - **Capture every conditional check, variable assignment, and state modification**
   - Use TLA+ assignment (variable' = value) for state changes
   - **DO NOT skip or abstract any critical logic in core functions**

3. **Control Structures**:
   - Translate if-statements to IF-THEN-ELSE
   - Translate loops to recursive actions or non-deterministic choices
   - Translate switch/case to nested IF-THEN-ELSE

## Source Code to Analyze:

{source_code}

## Instructions:

1. **Create Complete TLA+ Specification**: 
   - **Translate ALL CORE functions statement-by-statement as TLA+ actions with the same names**
   - **For each core function: translate every line of code, every conditional, every assignment**
   - **Preserve the exact algorithmic behavior and execution flow**
   - For distributed systems: Ensure BOTH consensus/election AND data replication are fully represented
   - Abstract HELPER functions appropriately
   - Omit INFRASTRUCTURE functions completely

2. **Ensure Rigorous Translation**: 
   - **Every critical operation in core functions must be captured**
   - **No simplification or abstraction of core logic**
   - **Faithful line-by-line translation is the priority**
   - Verify that all major subsystems are represented in the specification

Generate the complete TLA+ specification:

**IMPORTANT: Return ONLY the TLA+ code. Do not include any natural language explanations, comments about the translation process, or markdown formatting. Start directly with the module declaration and end with the module terminator.** 